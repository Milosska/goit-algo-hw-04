# Завдання 1: Порівняння алгоритмів сортування

Цей проєкт порівнює продуктивність трьох алгоритмів сортування в Python:

- Сортування вставками (власна реалізація)
- Сортування злиттям (власна реалізація)
- Timsort (sorted() – вбудована функція Python)

Мета – емпірично перевірити теоретичну складність цих алгоритмів та показати, чому вбудоване сортування Python є ефективним на практиці.

## Налаштування тестування

Тестували масиви різної довжини: 10, 100, 1000 елементів.
Тестували сортування масивів унікальних і повторювальних елементів.
Тестували сортування трьох випадків: найкращого (попередньо відсортований масив), середнього (не відсортований масив) та найгіршого (масив, відсортований в зворотньому порядку)
Час виконання вимірювався за допомогою модуля timeit.

## Інструкція щодо використання

1. Склонуйте репозиторій

```bash
git clone [repository-url]
cd goit-algo-hw-04
```

2. Перейдіть у директорію проєкту та активуйте віртуальне середовище

```bash
 python -m venv .venv
 # On Windows:
 .venv\Scripts\activate
 # On Unix/MacOS:
 source .venv/bin/activate
```

3. Встановіть необхідні залежності

```bash
# Install all dependencies (including development tools)
pip install -r requirements.txt
```

4. Запустіть головний файл main.py

```bash
# Install all dependencies (including development tools)
python -m main
```

5. Дотримуйтесь інструкцій у терміналі. Для вибору режиму сортування введіть **_'c'_**

6. Спостерігайте логування виконання, яке показує час роботи кожного алгоритму для різних масивів чисел.
   Зауважте, що оскільки масиви генеруються випадково під час кожного запуску, конкретні значення та час виконання можуть змінюватися.

## Аналіз та висновки

1. Сортування вставками (insertion sort):

   - Складність при найкращому випадку: **_O(n)_**
   - Складність при середньому/найгіршому випадку: **_O(n²)_**
   - Залежність від розміру масиву: найкраще працює для малих масивів, але сильно сповільнується зі збільшенням розміру масиву.
   - Наявність повторюваних елементів: чим менший розмір масиву, тим більший вплив на час сортування. Зі збільшенням розміру масиву різниця стає менш помітною через загальне збільшення часу роботи алгоритму.

2. Сортування злиттям (merge sort):

   - Складність при найкращому випадку: **_O(n log n)_**
   - Складність при середньому/найгіршому випадку: **_O(n log n)_**
   - Залежність від розміру масиву: показує стабільну швидкість незалежно від розміну масиву.
   - Наявність повторюваних елементів: може впливати на ефективність на малих та середніх масивах, на великих різниця майже зникає

3. Нативне сортування Python (Timsort):
   - Складність при найкращому випадку: **_O(n)_**
   - Складність при середньому/найгіршому випадку: **_O(n log n)_**
   - Залежність від розміру масиву: швидший за обидві власні реалізації на всіх тестованих масивах
   - Наявність повторюваних елементів: майже не впливає на швидкість сортування

#### Загальні висновки

З точки зору часу виконання найбільш оптимальним виявився Timsort. Хоча на малих масивах найкращі результати показав insertion sort, його швидкість сильно сповільнується пропорційно розміну масиву (20–30 разів повільніше для середніх масивів, 100+ разів повільніше для великих масивів). Timsort на 1000 елементах працює в межах 0.00007–0.00009 с, що швидше за merge sort (0.002–0.0028 с) та значно швидше за insertion sort(0.017–0.034 с).

Найбільш чутливим до структури масивів виявися insertion sort - зміна швидкості сортування між масивами з повторюваними і не повторюваними елементами мінімальна, однак стабільно присутня. Merge sort та Timsort майже не реагують на повторюваність елементів, показуючи стабільний результат у всіх сценаріях.

Щодо попереднього сортування масивів, найстабільніший результат показав merge sort, структура масиву не впливає на кількість рекурсій та злиттів. Для Timsort вплив попереднього сортування незначний і більше помітний на малих масивах, що пов'язано в викоританням поелементного порівняння на малих відсортованих сегментах. Для insertion sort вплив попереднього сортування є найбільшим, воно напрму впливає на кількість перестановок, які потрібно здійснити, щоб отримати бажаний результат.

На основі проведених тестів можна впевнено сказати, що вбудований алгоритм Python (Timsort) є найбільш ефективним у переважній більшості реальних задач через свою стабільність і оптимізацію. Його заміна на використання кастомних алгоритмів сортування може бути виправдана, але лише в умовах необхідності забезпечити специфічну поведінку, якої не має стандартна функція sorted() (наприклад, нестандартні правила порівняння, особливі вимоги щодо використання пам’яті тощо). Для звичайних прикладних задач найкращим вибором залишається вбудоване сортування, як найшвидше та найнадійніше.
